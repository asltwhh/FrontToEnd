# 二分查找

- 二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)
- 计算mid有两种方法：

```
mid = (lo+high)/2;
mid = lo+(hi-lo)/2;
```

- 一般由于第一种用法很可能会超出整型可表示的最大范围，所以会存在问题，所以一般推荐第二种写法
- 一般的循环条件都是`while(lo<high)`或者`while(lo<=high)`,这两种条件对应不同的mid取值
    - `while(lo<=high):lo=mid+1;high=mid-1;`
    - `while(lo<high):lo=mid;high=mid-1;`
    - `while(lo<high):lo=mid-1;high=mid;`
    - 否则循环无法退出

### 1 一般用法

```
搜索某个数组nums(不包含重复元素)中是否包含target,如果包含返回索引，否则返回-1
输入:[1,2,3,5,7] 7
输出:4
```

- 经典解法：
```
var binarySearch = function(nums, target) {
    let lo = 0, h = nums.loength - 1;
    while (lo <= h) {
        let mid = lo + (h - lo) / 2;
        if (nums[mid] == target) {
            return m;
        } else if (nums[mid] > key) {
            h = mid - 1;
        } else {
            lo = mid + 1;
        }
    }
    return -1;
}
```

- 变种1：包含重复元素，找到最小的target所在的索引

```
搜索某个数组nums(不包含重复元素)中是否包含target,如果包含返回target的第一个索引，否则返回-1
输入:[1,2,3,3,5,7,7,7,7] 7
输出:5
```

- 解法：查找key的最左边位置，返回lo
    - 只有当`nums[mid]<target`时，才改变左边的位置，这样lo始终就指向第一个不小于target的值的索引

```
var binarySearch = function(nums, target) {
    let lo = 0, h = nums.length - 1;
    while (lo <= h) {
        console.log(lo,h);
        let mid = parseInt(lo + (h - lo) / 2);
        // 重点是如果nums[mid]==target,则不改变左边的位置，只改变右边
        // 只有当nums[mid]<target时，才改变左边的位置，这样lo始终就指向第一个不小于target的值的索引
        if (nums[mid] < target) {
            lo = mid + 1;
        } else {
            h = mid - 1;
        }
    }
    return lo;
}
```

- 变种2：包含重复元素，找到最后一个target所在的索引

```
输入:[1,2,3,3,5,7,7,7,7] 7
输出:8
```

- 解法：查找key的最右边位置，返回lo-1
    - 当`nums[mid]<=target`时，改变lo，这样lo-1始终就指向最后一个target的值的索引
    - 如果是返回第一个大于指定值的元素的元素，则直接返回lo即可

```
var binarySearch = function(nums, target) {
    let lo = 0, h = nums.length - 1;
    while (lo <= h) {
        let mid = parseInt(lo + (h - lo) / 2);
        if (nums[mid] <= target) {
            lo = mid + 1;
        } else {
            h = mid - 1;
        }
    }
    return lo-1;
}
```

### 2 其他的变形

- 简单的
    - 167,35,367,69,744
- 中等
    - 旋转数组：33,153，这两者需要在取得mid之后判断左右是否为有序数组
    - 需要递归的：50,486，难一些，感觉没有看懂
    - 29,34,540
- 困难
    - 04:解法比较不常见
