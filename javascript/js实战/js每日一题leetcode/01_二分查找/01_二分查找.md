
<!-- TOC -->

- [1 二分查找的基本用法](#1-二分查找的基本用法)
  - [1.1 一般用法](#11-一般用法)
  - [1.2 变种1：包含重复元素，找到最小的target所在的索引](#12-变种1包含重复元素找到最小的target所在的索引)
  - [1.3 变种2：包含重复元素，找到最后一个target所在的索引](#13-变种2包含重复元素找到最后一个target所在的索引)
- [2 二分查找的经典题目](#2-二分查找的经典题目)
  - [2.1 一般的题目](#21-一般的题目)
    - [2.1.1 寻找重复数](#211-寻找重复数)
    - [2.1.2 在排序数组中查找元素的第一个和最后一个位置](#212-在排序数组中查找元素的第一个和最后一个位置)
  - [2.2 旋转排序数组](#22-旋转排序数组)
    - [2.2.1 搜索旋转排序数组(无重复元素)](#221-搜索旋转排序数组无重复元素)
    - [2.2.2 搜索旋转排序数组(有重复元素)](#222-搜索旋转排序数组有重复元素)
    - [2.2.3 旋转数组中的最小数字(无重复元素)](#223-旋转数组中的最小数字无重复元素)

<!-- /TOC -->

# 1 二分查找的基本用法

- 二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)
- 计算mid有两种方法：

```
mid = (lo+high)/2;
mid = lo+(hi-lo)/2;
```

- 一般由于第一种用法很可能会超出整型可表示的最大范围，所以会存在问题，所以一般推荐第二种写法
- 一般的循环条件都是`while(lo<high)`或者`while(lo<=high)`,这两种条件对应不同的mid取值
    - `while(lo<=high):lo=mid+1;high=mid-1;`
    - `while(lo<high):lo=mid;high=mid-1;`
    - `while(lo<high):lo=mid-1;high=mid;`
    - 否则循环无法退出

## 1.1 一般用法

```
搜索某个数组nums(不包含重复元素)中是否包含target,如果包含返回索引，否则返回-1
输入:[1,2,3,5,7] 7
输出:4
```

- 经典解法：
```
var binarySearch = function(nums, target) {
    let lo = 0, h = nums.loength - 1;
    while (lo <= h) {
        let mid = lo + (h - lo) / 2;
        if (nums[mid] == target) {
            return m;
        } else if (nums[mid] > key) {
            h = mid - 1;
        } else {
            lo = mid + 1;
        }
    }
    return -1;
}
```

## 1.2 变种1：包含重复元素，找到最小的target所在的索引

```
搜索某个数组nums(包含重复元素)中是否包含target,如果包含返回target的第一个索引，否则返回-1
输入:[1,2,3,3,5,7,7,7,7] 7
输出:5
```

- 解法：查找key的最左边位置，返回lo
    - 只有当`nums[mid]<target`时，才改变左边的位置，这样lo始终就指向第一个不小于target的值的索引

```
var binarySearch = function(nums, target) {
    let lo = 0, h = nums.length - 1;
    while (lo <= h) {
        console.log(lo,h);
        let mid = parseInt(lo + (h - lo) / 2);
        // 重点是如果nums[mid]==target,则不改变左边的位置，只改变右边
        // 只有当nums[mid]<target时，才改变左边的位置，这样lo始终就指向第一个不小于target的值的索引
        if (nums[mid] < target) {
            lo = mid + 1;
        } else {
            h = mid - 1;
        }
    }
    return lo;
}
```

## 1.3 变种2：包含重复元素，找到最后一个target所在的索引

```
输入:[1,2,3,3,5,7,7,7,7] 7
输出:8
```

- 解法：查找key的最右边位置，返回lo-1
    - 当`nums[mid]<=target`时，改变lo，这样lo始终就指向第一个大于target的值的索引
    - 如果是返回第一个大于指定值的元素的元素，则直接返回lo即可

```
var binarySearch = function(nums, target) {
    let lo = 0, h = nums.length - 1;
    while (lo <= h) {
        let mid = parseInt(lo + (h - lo) / 2);
        if (nums[mid] <= target) {
            lo = mid + 1;
        } else {
            h = mid - 1;
        }
    }
    return lo-1;
}
```

# 2 二分查找的经典题目

## 2.1 一般的题目

### 2.1.1 寻找重复数

leetcode 287 :注意给定数组的长度与其内在元素之间的关系

```
给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

示例 1:

输入: [1,3,4,2,2]
输出: 2
示例 2:

输入: [3,1,3,4,2]
输出: 3

说明：

不能更改原数组（假设数组是只读的）。
只能使用额外的 O(1) 的空间。
时间复杂度小于 O(n2) 。
数组中只有一个重复的数字，但它可能不止重复出现一次。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/find-the-duplicate-number
```

**解法1：双重循环暴力解法**  

时间复杂度O(n2),不满足条件 空间复杂度O(1)

外层循环依次取出每一个元素，内存循环负责将该元素与其后的所有元素进行比较，一旦发现具有相同的值，则说明该元素是重复的，返回该元素即可

```
function findDuplicate(nums){
    for(let i=0; i<nums.length-1; i++>){
        for(let j = i+1; j<nums.length; j++){
            if(nums[i] === nums[j]){
                return nums[i];
            }
        }
    }
    // 未发现重复值则返回false
    return false;
}
```

**解法2：哈希表**  

时间复杂度O(n)  空间复杂度O(n),不满足条件

依次遍历每个元素，创建一个哈希表保存每个元素出现的次数，然后遍历哈希表，一旦次数大于1，则返回该值

**解法3：二分查找**  

时间复杂度O(nlogn)  空间复杂度O(1)

分析：
- 由题目可知数组的长度为n+1,并且数组内元素的范围为[1,n],则如果1,...,n分别出现一次，还空了一个位置，说明一定有一个元素是重复的
- 令lo=1,hi=n,求得中位数mid,遍历数组得到小于等于mid的元素的数量count，如果mid之前的元素不重复，则小于等于mid的元素最多只有mid个，即
  - 如果count>mid,则说明重复元素在左边，则令hi=mid;
    - 例如[1,3,2,3] lo=1,hi=3,mid=2,count=2
    - 得到 lo=2,hi=3,mid=2,count=2
    - 得到lo=3,hi=3  lo=hi不满足条件则退出，返回3
  - 反之，则重复元素在右边，lo=mid+1;

```
function findDuplicate(nums){
    let lo = 1;
    let hi = nums.length-1;
    while(lo < hi>){
        let mid = parseInt((lo+hi)/2);
        let count = 0;
        nums.forEach((num) => {
            num <= mid ? ++count : count;
        })
        if(count>mid){
            hi = mid;
        }else{
            lo = mid+1;
        }
    }
    return lo;
}
```

### 2.1.2 在排序数组中查找元素的第一个和最后一个位置

leetcode 34. 

```
给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

你的算法时间复杂度必须是 O(log n) 级别。

如果数组中不存在目标值，返回 [-1, -1]。

示例 1:

输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
示例 2:

输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array
```

分析：
- 可以先通过二分查找的方法找到1个等于target的值
- 然后分别向前和向后查找等于target的值
  
```
var searchRange = function (nums, target) {
  let l = 0,
    r = nums.length - 1;
  let res = 0;
  while (l <= r) {
    let mid = parseInt((l + r) / 2);
    if (nums[mid] === target) {
      res = mid;
      break;
    } else if (nums[mid] < target) {
      l = mid + 1;
    } else {
      r = mid - 1;
    }
  }
  // 如果nums[res]不等于target，则说明数组中不存在等于target的元素
  if (nums[res] !== target) {
    return [-1, -1];
  }

  // 存在则分别向前向后查找
  let res1 = res;
  while (nums[res - 1] === target) {
    res--;
  }
  while (nums[res1 + 1] === target) {
    res1++;
  }
  return [res, res1];
};
```

改进：不用添加很多的中间变量

```
var searchRange = function (nums, target) {
  let l = 0,
    r = nums.length - 1;
  while (l <= r) {
    let mid = parseInt((l + r) / 2);
    if (nums[mid] < target) {
      l = mid + 1; //只有当nums[mid]<target时才移动l,所以l始终指向第一个不小于target的元素所在的位置
    } else {
      r = mid - 1;
    }
  }
  
  if (nums[l] == target) {
    // 存在target则向后查找最后一个target所在的位置
    let res = l;
    while (nums[res + 1] === target) {
      res++;
    }
    return [l, res];
  }else{
    // 如果nums[l]不等于target，则说明数组中不存在等于target的元素
    return [-1, -1];
  }
};
```

## 2.2 旋转排序数组

### 2.2.1 搜索旋转排序数组(无重复元素)

letcode 33. 

```
给你一个升序排列的整数数组 nums(无重复元素) ，和一个整数 target 。

假设按照升序排序的数组在预先未知的某个点上进行了旋转。（例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] ）。

请你在数组中搜索 target ，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。

你的算法时间复杂度必须是 O(log n) 级别。
 
示例 1：

输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
示例 2：

输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
示例 3：

输入：nums = [1], target = 0
输出：-1

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array
```

**解法1：暴力解法：遍历**

时间复杂度:O(n) 空间复杂度O(1)

```
function search(nums, target) {
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] === target) {
      return i;
    }
  }
  return -1;
}
```

**解法2：二分查找**

时间复杂度O(logn) 空间复杂度:O(1)

分析：
- 思想：二分查找
- 首先二分查找一般应用于有序数组中，所以我们需要先从中找出有序数组,而`任意选取一个mid得到的两个数组中有一个一定是有序数组`
    - while循环：
    - 先得到mid,判断nums[mid]是否等于target,等于则直接返回mid
    - 否则判断left,mid,right三个值的关系
        - left小于mid,则左边是有序数组
            - 判断是否存在left小于=target小于=mid,存在则说明target处于左边这一部分，则令right=mid-1;
            - 否则说明target处于右边部分，则left=mid+1;
        - left大于mid,则说明右边是有序数组
            -  判断是否存在mid小于=target小于=right,存在则说明target处于右边这一部分，则令left=mid+1;
            - 否则说明target处于左边部分，则right=mid-1;
    - 没有则返回-1


```
var search = function (nums, target) {
  let lo = 0;
  let hi = nums.length - 1;
  while (lo <= hi) {
    let mid = parseInt((lo + hi) / 2);

    if (nums[mid] === target) {
      return mid;
      // 注意这里的等于号
    } else if (nums[lo] <= nums[mid]) {
      // 左边是有序数组
      if (nums[lo] <= target && target < nums[mid]) {
        // target在左边
        hi = mid - 1;
      } else {
        // 目标在右边
        lo = mid + 1;
      }
    } else {
      // 右边是有序数组
      if (nums[mid] < target && target <= nums[hi]) {
        // target在右边
        lo = mid + 1;
      } else {
        // 目标在左边
        hi = mid - 1;
      }
    }
  }
  return -1;
};

```

注意其中的等号：等于号的存在主要是为了匹配下面的情况：

    nums=[3,1]  target=1

    lo=0 hi=1 mid=0 nums[lo]<=nums[mid] 进入判断 
        nums[lo]<target不成立，所以进入else,得到lo=1
    lo=1 hi=1 mid=1 nums[mid]=target  => mid

### 2.2.2 搜索旋转排序数组(有重复元素)

leetcode 81 

```
假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。

编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。

示例 1:

输入: nums = [2,5,6,0,0,1,2], target = 0
输出: true
示例 2:

输入: nums = [2,5,6,0,0,1,2], target = 3
输出: false

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii
```

分析：
- 基本与无重复元素的题目的做法相同
- 存在一个特殊情况：
  - [1,1,1] 如果出现这样的情况，则nums[l]=nums[mid]=nums[h]，则直接l++ h++直到l>h为止

```
var search =function(nums, target){  
    if(nums.length == 2){
        if(nums[0] == target || nums[1] == target){
            return true;
        }else{
            return false;
        }
    }      
    let l=0,r=nums.length-1;
    while(l<=r){
        let mid=parseInt((l+r)/2);
        if(nums[mid]==target){
            return true;
        }
        if(nums[mid]==nums[l]==nums[r]){
            l+=1;
            r-=1;
        }else if(nums[mid]>=nums[l]){
            if(nums[l]<=target && target<nums[mid]){
                r=mid-1;
            }else{
                l=mid+1;
            }    
        }else{
            if(nums[mid]<target && target<=nums[r]){
                l=mid+1;
            }
            else{
                r=mid-1;
            }     
        }  
    }
    return false;
}
```

### 2.2.3 旋转数组中的最小数字(无重复元素)

leetcode 153 

```
假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

请找出其中最小的元素。

你可以假设数组中不存在重复元素。

示例 1:

输入: [3,4,5,1,2]
输出: 1
示例 2:

输入: [4,5,6,7,0,1,2]
输出: 0

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array
```

**暴力解法1：直接排序，然后返回第一个元素**

时间复杂度：取决于排序算法的复杂度 空间复杂度O(1) 

```
var findMin = function(nums) {
    nums = nums.sort();
    return nums[0];
};
```

**解法2：二分查找**

时间复杂度：  空间复杂度O(1)

- 为了保证时间复杂度满足O(log(n)),则**需要使用二分查找，而二分查找需要保证数组是有序排列的，但是此数组发生了旋转，所以可以判断在取得mid之后左右数组是否是有序数组**
- 思想：寻找最小的数
    - 首先，我们令min=nums[0],由于发生了旋转，此时min一定不是最小的数
    - 所以通过二分查找，如果存在nums[0]<=nums[mid],则说明此时左边是一个有序数组，此时左边数组中最小的数就是nums[0],所以要找更小的数，就令lo=mid+1;
    - 如果nums[0]<=nums[mid]不成立，则说明右边是一个有序数组，则比较min和nums[mid],取较小者赋值给min，然后令hi=mid-1;继续往前寻找更小的数
    - 直到lo>hi,不满足循环条件，则就找到最小的min了
```
var findMin = function (nums) {
  let lo = 0;
  let hi = nums.length - 1;
  let min = nums[lo];
  while (lo <= hi) {
    let mid = parseInt((lo + hi) / 2);
    if (nums[0] <= nums[mid]) {
      // 左边有序,mid肯定不是最小值，min在mid的右边
      lo = mid + 1;
    } else {
      // 右边有序，mid可能是min，所以需要比较
      min = nums[mid] < min ? nums[mid] : min;
      // 继续向前寻找min
      hi = mid - 1;
    }
  }
  return min;
};
```


