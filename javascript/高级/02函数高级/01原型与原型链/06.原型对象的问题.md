#原型对象的问题
当原型对象中包含引用类型值的属性：

对于下面的例子：friends属性属于原型对象，所有实例对象共享，并且它是一个Array引用类型，push方法之后相当于全部对于实例对象的friends属性做了修改，在不添加其余属性的情况下，新创建的实例是完全相同的，没有意义
```
functionPerson(){
}
Person.prototype={
    constructor:Person,
    name:"Nicholas",
    age:29,
    job:"SoftwareEngineer",
    friends:["Shelby","Court"],
    sayName:function(){
        alert(this.name);
    }
};
varperson1=newPerson();
varperson2=newPerson();
person1.friends.push("Van");
alert(person1.friends);//"Shelby,Court,Van"
alert(person2.friends);//"Shelby,Court,Van"
alert(person1.friends===person2.friends);//true
```

#解决办法1：构造函数和原型函数共同使用
方法是通用的，其余的不同的属性通过构造函数的方法创建
```
functionPerson(name,age,job){
    this.name=name;
    this.age=age;
    this.job=job;
    this.friends=["Shelby","Court"];
}
Person.prototype={
    constructor:Person,
    sayName:function(){
        alert(this.name);
    }
}
varperson1=newPerson("Nicholas",29,"SoftwareEngineer");
varperson2=newPerson("Greg",27,"Doctor");
person1.friends.push("Van");
alert(person1.friends);//"Shelby,Count,Van"
alert(person2.friends);//"Shelby,Count"
alert(person1.friends===person2.friends);//false
alert(person1.sayName===person2.sayName);//true
```

#解决方法2：
```
functionPerson(name,age,job){
    this.name=name;
    this.age=age;
    this.job=job;
    this.friends=["Shelby","Court"];
}
Person.prototype={
    constructor:Person,
    sayName:function(){
        alert(this.name);
    }

    //初始化构造对象时，如果该对象不具备sayname函数，则创建该函数
    if(typeofthis.sayName!="function"){
        Person.prototype.sayName=function(){
            alert(this.name);
        };

    }
}